# 基因组重测序分析与脚本使用教程（系统发育篇）

**脚本获取：** 本教程中使用的所有Python脚本 (`1` 到 `5`) 均可从以下 Gitee 仓库获取：
https://gitee.com/jhe1004/phylo-analysis-scripts/tree/main/22_re-sequencing/ReSeqPipline

欢迎使用本教程！本教程旨在帮助初学者理解什么是基因组重测序，并指导你如何使用这套特定的Python脚本，**通过重测序数据获取物种的基因组序列，以用于系统发育分析**。

## 1. 什么是基因组重测序？

**基因组重测序（Resequencing）** 是指对一个已知参考基因组序列的物种，测定一个个体或群体的基因组序列，并将其与参考基因组进行比对。

这一定义听起来很简单，但它涵盖了多种目的。让我们来详细说明**本教程的目的**：**为系统发育分析获取基因组序列**。

### 我们的目标：构建系统发育树

当你的研究目标是**系统发育分析**（即构建“生命之树”）时，你需要的核心材料是来自**多个不同物种**的、可供比较的基因组序列。最理想的情况是拿到每个物种完整的基因组（FASTA格式）。

然而，为几十个物种都进行**从头组装（*de novo* assembly）**——即完全不依赖任何参考，从零开始拼装一个新物种的基因组——是一个极其昂贵且计算密集的过程。

### 我们的方法：参考组装（Reference-based Assembly）

这就是重测序技术发挥作用的地方。我们可以走一条更经济、更高效的捷径：

1.  **选择一个“锚”:** 我们只需要一个**近缘物种**的、组装质量较高的基因组。这“一个”基因组将作为我们所有分析的“参考”（Reference）或“底板”。（在后面的比喻中，这就是“猫”的拼图）
2.  **批量测序:** 对我们感兴趣的所有其他物种（比如我们要研究的十几个老虎亚种），我们只需要进行标准的、相对便宜的“重测序”（产生大量的短读序列，即FASTQ文件）。（这就是“老虎”的碎片）
3.  **拼装:** 我们利用“参考”作为指导，将每个物种的短读序列（碎片）“贴”上去，从而“拼装”出这个物种的完整基因组序列。

这个过程就叫做**“参考组装”（Reference-based Assembly）**。

### 这套脚本的用途

**这套脚本的用途，就是实现上述“参考组装”的流程。**

它会带领你，利用一个近缘物种的基因组（参考）作为“脚手架”，把你新测序的物种数据（Reads）搭建上去，最终为你“拼装”出一个你新物种的**“一致性序列（Consensus Sequence）”**。

这个“一致性序列”（FASTA文件）就是你构建系统发育树所需要的最终输入数据。它代表了你测序物种的基因组序列，在参考基因组的框架下，它是什么样子。

## 2. 分析流程：获取一致性序列

本教程的目标是**系统发育分析**，因此我们的分析流程专注于获取物种的基因组序列（FASTA文件）。

流程步骤如下：

1.  **数据质控（QC）**: （可选，但推荐）对原始测序数据进行质量评估和过滤。
2.  **参考基因组准备**: 选择一个近缘物种的基因组作为参考，并为其建立索引。
3.  **序列比对（Mapping）**: 将你的测序数据比对到参考基因组上。
4.  **比对后处理**: 对BAM文件进行排序和索引（由脚本2自动完成）。
5.  **生成一致性序列（Get Consensus Fasta）**: 根据比对结果，为每个样本生成FASTA格式的基因组序列。
6.  **(新增) 序列质量检查 (Check Non-ATCG)**: 统计每个序列中“N”碱基的比例，评估质量。
7.  **(新增) 合并所有序列 (Combine Fasta)**: 将所有样本的FASTA序列合并成一个多序列FASTA文件，用于后续分析。

## 3. 原理详解：这套脚本是如何工作的？

为了让初学者彻底明白，我们来打个比方。

想象一下，你想拼一幅你新测序物种（比如**老虎**）的拼图，但你手上没有完整的图样，只有几千万块**老虎**拼图的微小碎片（这就是你的**测序数据 Reads**）。

不过，你有一幅完整的、拼好的近缘物种的拼图（比如一只**猫**）。这幅“猫”的拼图，就是你的**参考基因组（Reference Genome）**。

这套脚本的工作，就是利用“猫”的拼图底板，来拼出“老虎”的完整拼图。

---

### 步骤一 (`1_index_reference.py`)：给“猫”的拼图建立索引

* **作用：** 这个脚本不会碰你的“老虎”碎片。它只负责分析“猫”的拼图（参考基因组）。
* **比喻：** 它会为“猫”的拼图制作一个详细的“索引”或“地图”。比如它会记录：“左上角是耳朵”、“中间是肚子”、“坐标(10, 20)是白色的毛”。
* **产出：** 一堆索引文件（`.bwt`, `.fai`等）。这些文件让电脑在下一步能以毫秒级的速度查到“猫”拼图的任何一个位置。

---

### 步骤二 (`2_bwa_map.py`)：把“老虎”的碎片贴到“猫”的拼图上

* **作用：** 这是最关键的**比对（Mapping）**步骤。
* **比喻：** 脚本会拿起你手上**第一块“老虎”碎片**（一条Read），这块碎片可能是黄黑色的毛。它会去查“猫”的索引：“猫的哪个部位和这块黄黑色的毛最像？”
* 索引回答：“猫的肚子中间（坐标(50, 60)）也是黄色的毛，虽然花纹不一样，但相似度最高。”
* 于是，脚本就把这块“老虎”碎片（Read）“贴”在“猫”拼图（Reference）坐标(50, 60)的位置上。
* 脚本会重复这个动作**亿万次**，把你所有的“老虎”碎片（Reads）都尽可能地贴在“猫”拼图上所有相似的位置。
* **产出：** BAM文件。你可以把BAM文件想象成：**一幅“猫”的拼图底板上，密密麻麻、重重叠叠地贴满了“老虎”的碎片**。

---

### 步骤三 (`3_get_fasta.py`)：根据贴好的碎片，生成“老虎”的拼图

* **作用：** 生成你真正想要的“老虎”基因组（一致性序列）。
* **比喻：** 脚本现在开始从头到尾“扫描”这幅贴满了碎片的拼图。
    1.  脚本来到**第一个位置**（坐标1）。它发现“猫”的底板是**白色**的（碱基A），但这个位置上贴了**10片“老虎”碎片**，这10片碎片**全都是黑色**的（碱基G）。
    2.  脚本会进行“投票”（即检查 `MIN_COVERAGE_THRESHOLD = 3`）。它会问：这个位置上的碎片数量是否超过3片？答案是10，超过了。
    3.  然后它会看这些碎片上占主导的图案是什么？发现10片都是“黑色”（G）。
    4.  于是，脚本在**最终“老虎”拼图**的第一个位置，记下了**“黑色”（G）**。
    5.  脚本来到**第二个位置**（坐标2）。它发现“猫”的底板是白色的，但这个位置上只贴了**1片“老虎”碎片**。
    6.  脚本再次“投票”：碎片数量（1）是否超过3片？没有超过。脚本认为这个位置的信息不可靠（覆盖度太低）。
    7.  于是，脚本在**最终“老虎”拼图**的第二个位置，记下一个**“N”（代表未知）**。
    8.  脚本就这样一个碱基一个碱基、一个位置一个位置地走完整个基因组……
* **产出：** `_consensus.fasta` 文件。这就是根据你的测序数据，“拼装”出来的“老虎”的完整基因组序列。

---

### (新增) 步骤四 (`4_check_non_atcg.py`)：检查“老虎”拼图的质量

* **作用：** 这是一个**质量控制（QC）**步骤。
* **比喻：** 拿到了拼好的“老虎”拼图（FASTA文件），我们现在要用放大镜检查一下。这个脚本会帮我们统计：“这幅拼图里有多少块是模糊不清的（即碱基‘N’）？”
* **产出：** 一个打印在屏幕上的**总结表格**，告诉你每个样本的FASTA文件里，“非ATCG”碱基（主要是N）占了百分之多少。如果一个样本的“N”比例特别高（比如50%），说明这个样本的测序深度可能不够，拼出来的拼图质量很差，你可能要考虑在后续分析中舍弃它。

---

### (新增) 步骤五 (`5_combine_fasta.py`)：把所有拼图打包成一本书

* **作用：** 这是**最后的数据准备**步骤。
* **比喻：** 你现在有了 “老虎”拼图、“狮子”拼图、“豹子”拼图...（每个样本一个FASTA文件）。为了方便比较它们，你需要把它们整理成**一本书**。这个脚本就是把所有单独的拼图（FASTA文件）按顺序（每个样本一页）装订起来，做成一个“物种比较图册”（即 `combined_sequences.fasta`）。
* **产出：** 一个**单一的FASTA文件** (`combined_sequences.fasta`)，它包含了所有样本的序列。这个文件就是你拿去做系统发育分析（例如用MAFFT做多序列比对，或用IQ-TREE建树）的最终输入文件。

## 4. 本套脚本的特定分析流程

现在你已经理解了原理，再来看这套脚本的工作流程就会非常清晰：

1.  **步骤一 (`1_index_reference.py`):** 准备和索引参考基因组（制作“猫”拼图的索引地图）。
2.  **步骤二 (`2_bwa_map.py`):** 将所有样本（你要分析的物种）的FASTQ数据比对到参考基因组（把“老虎”碎片贴到“猫”的底板上），并生成BAM文件。
3.  **步骤三 (`3_get_fasta.py`):** 读取第二步生成的BAM文件，为每个样本（物种）生成一个FASTA格式的一致性序列（扫描贴满碎片的拼图，生成“老虎”的最终序列）。
4.  **(新增) 步骤四 (`4_check_non_atcg.py`):** （质控）检查第三步生成的每个FASTA文件，统计N碱基的比例。
5.  **(新增) 步骤五 (`5_combine_fasta.py`):** （打包）将所有质控合格的FASTA文件合并成一个多序列FASTA文件。

这些生成的FASTA序列，就可以直接用于后续的多序列比对和系统发育树构建。

## 5. 准备工作：环境与数据

在开始之前，请确保你准备好了以下软件和数据。

### 5.1. 所需软件（安装）

你需要一个Linux/macOS环境，并安装以下软件：

1.  **Python 3:** 确保你的Python环境中安装了 `pysam` 和 `biopython` 库。

    ```bash
    pip install pysam biopython
    ```

2.  **BWA:** 一款高效的序列比对软件。

    ```bash
    conda install bwa
    ```

3.  **Samtools:** 用于处理BAM/SAM文件的工具集。

    ```bash
    conda install samtools
    ```

### 5.2. 所需数据（准备）

1.  **参考基因组 (Reference Genome):**
    * 一个FASTA格式的文件（例如 `ref.fasta`），包含一个与你测序物种**亲缘关系较近**的物种的基因组序列（“猫”的拼图）。
    * **重要建议 (必读):** 正如你所提议的，如果你的参考基因组**组装得非常零碎**（例如，有成千上万条contigs或scaffolds），**强烈建议你先进行预处理**。
    * **处理方法：** 在运行脚本之前，使用Geneious、SeqKit或自定义脚本，**将所有的染色体/Scaffolds连接（Concatenate）成一条或少数几条序列**（例如，中间用`NNNNN`分隔）。
    * **原因：** 这样做可以极大提高后续比对和处理的效率，避免软件在处理海量小片段时性能下降或出错。处理后的基因组（例如 `ref_combined.fasta`）将作为你后续所有步骤的输入。

2.  **测序数据 (Raw Reads):**
    * 所有样本（即你要放在发育树上的物种）的双端（Paired-end）测序数据，通常是FASTQ格式（例如 `species1_1.fastq.gz` 和 `species1_2.fastq.gz`）（“老虎”的碎片）。
    * 将所有这些FASTQ文件放在一个文件夹中。

## 6. 详细步骤：如何使用脚本

假设你已经安装好了软件，并准备好了`ref_combined.fasta`（处理后的参考基因组）和一个存放所有FASTQ文件的文件夹（例如 `./fastq_files/`）。

### 步骤一：索引参考基因组

**脚本:** `1_index_reference.py`

**目的:** 为BWA和Samtools创建参考基因组的索引文件（制作“猫”拼图的索引地图）。

**如何运行:**
打开终端，运行以下命令。将 `-r` 参数指向你准备好的参考基因组文件。

    ```bash
    python 1_index_reference.py -r ref_combined.fasta
    ```

**执行内容:**
这个脚本会依次执行以下两个命令：

1.  `bwa index -a bwtsw ref_combined.fasta` (为BWA创建索引)
2.  `samtools faidx ref_combined.fasta` (创建FASTA索引，用于快速访问)

**产出:**
在 `ref_combined.fasta` 所在的目录，你会看到一堆新的索引文件（如 `.amb`, `.ann`, `.bwt`, `.pac`, `.sa`, `.fai`）。

### 步骤二：序列比对与BAM生成

**脚本:** `2_bwa_map.py`

**目的:** 自动发现FASTQ文件夹中的所有样本，并将它们（逐个）比对到参考基因组（把“老虎”碎片贴到“猫”的底板上），最终生成排序并索引好的BAM文件。

**如何运行:**
这是一个批量处理脚本。你需要指定参考基因组、线程数、FASTQ文件的后缀名以及FASTQ文件所在的文件夹。

    ```bash
    # 示例命令
    python 2_bwa_map.py \
        -r ref_combined.fasta \
        -t 8 \
        -p _1.fastq.gz \
        -m _2.fastq.gz \
        -f ./fastq_files/
    ```

**参数说明:**

* `-r ref_combined.fasta`: 你在**步骤一**中索引的同一个参考基因组。
* `-t 8`: 使用的CPU线程数（根据你的电脑配置修改）。
* `-p _1.fastq.gz`: **非常重要！** 你的正向reads（R1）的文件后缀。
    * 如果你的文件是 `SampleA_R1.fq.gz`，这里就应该填 `_R1.fq.gz`。
    * 如果你的文件是 `SampleA_1.fastq.gz`，这里就填 `_1.fastq.gz`。
* `-m _2.fastq.gz`: **非常重要！** 对应的反向reads（R2）的文件后缀。
    * 对应上面的例子，这里应该填 `_R2.fq.gz` 或 `_2.fastq.gz`。
* `-f ./fastq_files/`: 存放所有FASTQ文件的文件夹路径。如果不指定，默认为当前文件夹。

**执行内容:**
脚本会为 `fastq_files` 文件夹中的**每一个**样本执行 `bwa mem` -> `samtools sort` -> `samtools index` 的完整流程。

**产出:**
在 `-f` 指定的文件夹（或当前文件夹）中，你会为每个样本（如 `SampleA`）生成两个文件：

* `SampleA.bam` (排序后的比对文件)
* `SampleA.bam.csi` (或 `.bai`，BAM索引文件)

### 步骤三：生成一致性FASTA序列

**脚本:** `3_get_fasta.py`

**目的:** 读取**步骤二**中生成的所有BAM文件，并为**每一个**BAM文件生成一个FASTA格式的一致性基因组序列（扫描贴满碎片的拼图，生成“老虎”的最终序列）。

**如何运行:**
这个脚本**不需要**命令行参数，你需要**直接编辑脚本内部的参数**。

1.  用文本编辑器打开 `3_get_fasta.py`。
2.  找到文件开头的 `脚本参数定义` 部分，修改以下路径：

    ```python
    ################################################################################
    # 脚本参数定义 (请在此处修改您的文件路径和参数)
    ################################################################################
    
    # 1. 输入参数
    # 物种A的参考基因组FASTA文件路径 (必须与步骤1和2中使用的一致)
    REF_FASTA_PATH = "ref_combined.fasta" 
    
    # 包含一个或多个BAM文件的文件夹路径 (步骤2的BAM产出文件夹)
    BAM_FOLDER_PATH = "./fastq_files/" # 或者你存放BAM的任何地方
    
    # 2. 输出参数
    # 生成的FASTA一致性序列的输出文件夹路径
    OUTPUT_FOLDER_PATH = "./consensus_fasta_output/"
    
    # 3. 处理参数
    MIN_COVERAGE_THRESHOLD = 3  # 最小覆盖度阈值（“投票”门槛）
    MIN_MAPPING_QUALITY_THRESHOLD = 10 # 最小比对质量（贴歪了的碎片不要）
    
    # 4. 并行处理参数
    # 你想同时处理多少个BAM文件 (例如 4 或 8)
    NUM_PARALLEL_PROCESSES = 4 
    
    ################################################################################
    ```

3.  **修改参数的意义：**
    * `REF_FASTA_PATH`: 必须是步骤1和2中使用的那个 `ref_combined.fasta`。
    * `BAM_FOLDER_PATH`: 必须是**步骤二**中生成 `.bam` 和 `.bam.csi` 文件的那个文件夹。
    * `OUTPUT_FOLDER_PATH`: 脚本会自动创建这个文件夹，用于存放最终的FASTA结果。
    * `MIN_COVERAGE_THRESHOLD`: 核心参数（“投票”门槛）。例如设为3，意味着在一个位置，必须至少有3片“老虎”碎片，脚本才认可这个位置的“投票”结果；否则，该位置将被记为 'N'。
    * `MIN_MAPPING_QUALITY_THRESHOLD`: 过滤掉那些“贴歪了”的碎片。如果一个碎片和它所贴的位置相似度很低（比对质量差），在“投票”时就会被忽略。
    * `NUM_PARALLEL_PROCESSES`: 如果你有很多BAM文件，设置一个大于1的数（如4或8）可以并行处理，大大加快速度。

4.  保存修改后，在终端运行：

    ```bash
    python 3_get_fasta.py
    ```

**产出:**
在 `OUTPUT_FOLDER_PATH`（例如 `./consensus_fasta_output/`）中，你会为每个BAM文件（如 `SampleA.bam`）得到一个对应的一致性序列文件（如 `SampleA_consensus.fasta`）。

### (新增) 步骤四：检查一致性序列质量

**脚本:** `4_check_non_atcg.py`

**目的:** 检查**步骤三**生成的每个FASTA文件，统计其中非ATCG碱基（主要是'N'）的比例。这是一个关键的质控步骤。

**如何运行:**
这个脚本会检查**当前工作目录**下的所有FASTA文件。

1.  首先，进入**步骤三**的输出文件夹：

    ```bash
    cd consensus_fasta_output/
    ```

2.  将 `4_check_non_atcg.py` 脚本**复制**到这个文件夹中。

3.  运行脚本：

    ```bash
    python 4_check_non_atcg.py
    ```

**产出:**
脚本会直接在终端打印出一个表格，显示每个FASTA文件的总碱基数、非ATCG碱基数以及百分比。

* **解读：** 密切关注 `Ratio (%)` 这一列。如果某个样本（例如 `SampleB_consensus.fasta`）的比例非常高（比如 > 20% 或 50%），这表明该样本的测序深度可能严重不足，导致拼图质量很差。你可能需要考虑在下一步（合并）之前**手动删除**这个低质量的FASTA文件。

### (新增) 步骤五：合并所有FASTA文件（打包）

**脚本:** `5_combine_fasta.py`

**目的:** 将所有（通过了上一步质控的）FASTA文件合并成一个**单一的、多序列FASTA文件**。这个文件**已经是一个多序列比对矩阵(MSA)**，可直接用于后续的位点过滤（Gap/N filtering）和系统发育分析。

**如何运行:**
这个脚本同样在**当前工作目录**下运行。

1.  确保你仍**位于 `consensus_fasta_output/` 文件夹中**。（如果你在上一步质控中删除了某些低质量的FASTA文件，确保它们已被删除）。

2.  将 `5_combine_fasta.py` 脚本**复制**到这个文件夹中。

3.  运行脚本：

    ```bash
    python 5_combine_fasta.py
    ```

**产出:**
在**当前文件夹** (`consensus_fasta_output/`) 中生成一个名为 `combined_sequences.fasta` 的文件。

* **内容：** 这个文件包含了该文件夹中所有其他FASTA文件的序列。例如，`SampleA_consensus.fasta` 里的序列，在这个合并文件中的序列头会变成 `>SampleA_consensus`。

## 7. 总结与后续分析

恭喜你！完成以上五步后，你就为你的每个样本（物种）都获得了一个基于参考基因组比对结果的、全新的一致性基因组序列（“老虎”的完整拼图），并且你已经完成了质控和打包。

你最终得到的 `combined_sequences.fasta` 文件，就是你的**最终成果**。

**一个重要的概念：** 由于你所有的序列都是基于**同一个参考基因组**（“猫”的拼图）拼装出来的，它们天然就共享同一个坐标系，并且长度完全相同。

这意味着 `combined_sequences.fasta` 文件 **已经是一个多序列比对矩阵了**！你**不需要（也不应该）**再使用 MAFFT 或 ClustalW 等软件进行比对。

**你可以利用这个 `combined_sequences.fasta` 文件做什么？**

* **过滤比对矩阵 (Trim Gaps/Ns):** 这是构建系统发育树的**必须步骤**。你的矩阵中可能有很多列（位点）包含了大量的 'N' (代表低覆盖度或缺失数据)。这些充满缺失数据的列会干扰建树的准确性。
    * 你需要使用像 `DelMissingSite` (https://github.com/Jhe1004/DelMissingSite) 这样的工具，来删除那些 'N' 比例过高的列（Site）。

* **构建系统发育树:** 将上一步**过滤后**的FASTA矩阵文件（例如 `trimmed_matrix.fasta`）直接输入到 `IQ-TREE`, `RAxML`, `FastTree` 或 `PHYLIP` 等软件中，构建系统发育关系。

希望这份教程对你有帮助！